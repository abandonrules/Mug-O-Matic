/* 
Mug-O-Matic/Post-It-Plotter- Gcode Reading Program
A complicated Arduino Sketch to read gcode sent via serial by a computer running processing.

HW License: Attribution-ShareAlike CC BY-SA 4.0
Last Updated AUG 2018

Attribution Credits:
 TO UPDATE BASED ON THAT GUY WHO MOSTLY CREATED THIS<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  Modified for current use by Michael Graham, https://engineerdog.com/
  Based on work by Makerblock, http://shor.tw/110
  Based on work by Heindal, https://www.thingiverse.com/thing:667454
  Based on work by Oliv4945: https://github.com/Oliv4945/GcodeMiniCNChttps://github.com/Oliv4945/Gc
 
// The Circuit per PINOUT IMAGE http://meped.io/mepedv2
//  A0 =  (Wifi Connection if in use)
//  A1 =  (Wifi Connection if in use)
//  A2 = (Ultrasonic Echo if in use)
//  A3 = (Ultrasonic Trig if in use)
//  A4 = (SCA Connection if in use)
//  A5 = (I2C SCL Connection if in use)
//  A6 = 
//  A7 = 
//  D0 (RX) = (Bluetooth TX connection if in use)
//  D1 (TX) = (Bluetooth RX connection if in use)
//  D2(S1) =  X axis servo
//  D3~(S2)= Y axis servo
//  D4(S3) =  Z axis servo
//  D5~(S4) =  
//  D6~(S5)= 
//  D7(S6)=  
//  D8(S7) =  
//  D9~(S8) = 
//  D10~(S9) = Buzzer long leg
//  D11~ = 
//  D12 = (IR Remote Input if in use)
//  D13 = (Embedded LED on this pin)
//  Any 5V =  
//  Any GND = Buzzer short leg
*/

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*DECLARATIONS*
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <Servo.h>

#define PIN_SERVO_X 2
#define PIN_SERVO_Y 3
#define PIN_SERVO_Z 4
#define LINE_BUFFER_LENGTH 30//512
//#define MOVEMENT_MIN 0
//#define MOVEMENT_MAX 80 
//#define STEP_DELAY 25  //ms
#define BACKLASH 1.5
//#define POSITIVE true
//#define NEGATIVE false

//Naming Components & Global Variables
struct point {
  float x;
  boolean xDirection;
  float y;
  boolean yDirection;
  float z;
  boolean zDirection;
};
struct point actuatorPos;
Servo servoX;
Servo servoY;
Servo servoZ;

float deg2mmRack(float deg) {return deg/2.25;} //  Converts mm to degrees for the servos.  2.25 is hard set by 180deg/80mm motion
float mm2degRack(float mm) {return mm*2.25;} //  Converts mm to degrees for the servos. 2.25 is hard set by 180deg/80mm motion
float deg2mmPivot(float deg) {return deg/1.5;} //  Converts mm to degrees for the servos.  2.25 is hard set by 180deg/80mm motion
float mm2degPivot(float mm) {return mm*1.5;} //(2.25/1.8)  Converts mm to degrees for the servos. 2.25 is hard set by 180deg/80mm motion


// Define drawing settings
float BacklashAngleX = 3.5;//4;// deg added to all moves if a direction change occurs to account for slop/backlash in the system (This was a measured angle)
float BacklashAngleY = 1; //1 deg added to all moves if a direction change occurs to account for slop/backlash in the system (This was a measured angle)
float Resolution = 1.25;// 1.75; //mm of minimum DIRECT drawing resolution to consolidate impossible moves less than this distance into one movement of this length.
float DotResolution = .4;//1.0;// 1.75; //mm of minimum DOT drawing resolution to consolidate impossible moves less than this distance into one movement of this length.

int StepDelay = 30; //ms delay between steps to ensure steps are independent moves. 
int DotStepDelay = 60; //75 ms delay between steps to ensure steps are independent moves. 

int LineDelay = 150; //ms delay after line move to ensure move is completed
int penDelay = 250; //ms delay to ensure pen move is completed
float oldDirX =0; //-1,0,1. Place holder to record the direction of the last motion in this axis to use for backlash correction.
float newDirX =0; //-1,0,1. Place holder to record the direction of the last motion in this axis to use for backlash correction.
float oldDirY =0; //-1,0,1. Place holder to record the direction of the last motion in this axis to use for backlash correction.
float newDirY =0; //-1,0,1. Place holder to record the direction of the last motion in this axis to use for backlash correction.


//Specific to Mug-O-Matic NEWER
//  Define Robot limits, in degrees
float Xdmin = 12.0+13.0;  //43 if choked up
float Xdmax = 148.0+11.0;//148+13; //137 if choked up
float Ydmin = 7;//2;//8-6  
float Ydmax = 180.0;//-2;  
float Zdmin = 20.0; // 10. Dont want too tight or loose enough to lose contact!
float ZdTouch = 25; // The exact angle that you touch pen to mug
float Zdmax = 36.0; //  Lifted Pen Position


/*
//Specific to Mug-O-Matic
//  Define Robot limits, in degrees
int Xdmin = 12;  //43 if choked up
int Xdmax = 148; //137 if choked up
int Ydmin = 8;  
int Ydmax = 173;  
int Zdmin = 10; // 10. Dont want too tight or loose enough to lose contact!
int Zdmax = 50; //  Lifted Pen Position
*/

////////////////////////////////////////
////////////


//  Calculated drawing robot limits, in mm
float Xmin = deg2mmPivot(Xdmin);
float Xmax = deg2mmPivot(Xdmax);
float Ymin = deg2mmRack(Ydmin);
float Ymax = deg2mmRack(Ydmax);
float Zmin = deg2mmRack(Zdmin);
float Zmax = deg2mmRack(Zdmax);
float Xpos = Xdmin;   //Home Position (deg)
float Ypos = Ydmin;  //Home Position (deg)
float Zpos = Zdmax; //Home Position (deg)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*SETUP*
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void setup() {
  Serial.begin( 9600 );
  servoX.attach( PIN_SERVO_X );
  servoY.attach( PIN_SERVO_Y );
  servoZ.attach( PIN_SERVO_Z );
  // Set default positions
  	delay(1000);	
     home();
  actuatorPos.x = Xdmin;
  actuatorPos.y = Ydmax;
  actuatorPos.z = Zdmax;
  
 //drawRect(Xmin,Ymin,Xmax,Ymax,true); //(x0, y0, x1, y1, boolean pen toggle (dry run if set false)). Units are millimeters
 // drawDotRect(Xmin+33,Ymin+29,Xmin+53,Ymin+49,true); //(x0, y0, x1, y1, boolean pen toggle (dry run if set false)). Units are millimeters
  //drawRect(Xmin+30,Ymin+26,Xmin+56,Ymin+52,true); //(x0, y0, x1, y1, boolean pen toggle (dry run if set false)). Units are millimeters
 //drawRectSpiral(Xmin,Ymin,Xmax,Ymax,6, true); //(x0, y0, x1, y1, spiral spacing, boolean pen toggle (dry run if set false)). Units are millimeters
 //drawDotRect(Xmin+20,Ymin+20,Xmin+40,Ymin+40,true); //(x0, y0, x1, y1, boolean pen toggle (dry run if set false)). Units are millimeters
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* Main loop*
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void loop() {
  char line[ LINE_BUFFER_LENGTH ];
  char c; 
  int lineIndex;
  bool lineIsComment, lineIsSemiColon;
  bool commandFound; // has a command been found 
 
  lineIndex = 0;
  lineIsSemiColon = false;
  lineIsComment = false;
  commandFound = false;
 
 while (true) { 
    // Serial reception - Mostly from Grbl, added semicolon support
    while ( Serial.available()>0 ) {
      c = Serial.peek();
      if ( ( c == 'G' || c == 'M' ) && commandFound ) { // check if the next character starts a new command
        c = '\n'; // insert a end of line character and skip reading the serial buffer to end the command  
      }else {
        c = Serial.read();
      }
      switch (c) {
        case '\n': // End of line reached
        case '\r':                         
          if ( lineIndex > 0 && commandFound ) {                        // Line or command is complete. Then execute!
            line[ lineIndex ] = '\0';                   // Terminate string
            //Serial.print( "// Received "); Serial.println( line );
            processIncomingLine( line, lineIndex );
            lineIndex = 0;
            commandFound = false; // reset the command found flag to false
            lineIsComment = false;
            lineIsSemiColon = false;
          } else { 
            // Empty or comment line. Skip block.
          }
          break;
        case ';':
          lineIsSemiColon = true;
          break;
        case '(':
          lineIsComment = true;
          break;
        case ')':
          lineIsComment = false;
          break;
        case ' ':  // Throw away whitepace and control characters
        case '/':
          break;
        case 'G': 
        case 'M':
          commandFound = true;
        default:
          if ( (!lineIsComment) && (!lineIsSemiColon) ) {   // Only save if not comments
            if ( c >= 'a' && c <= 'z' ) {        // Upcase lowercase
              line[ lineIndex++ ] = c-'a'+'A';
            } else {
              line[ lineIndex++ ] = c;
            }
          }
          break;
       }
    }
  }

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*Function Definitions*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
/**********************
* void processIncomingLine( char* line, int charNB ) - Main loop
* char* line : Line to process
* int charNB : Number of characters
***********************/
void processIncomingLine( char* line, int charNB ) {
  int currentIndex = 0;
  char buffer[ 64 ];                                 // Hope that 64 is enough for 1 parameter
  struct point newPos;
  
  newPos = actuatorPos; // Set new position to current servo position, individual values are reused if new ones not list in command 
  //////////////////////////////////////THIS LINE IS IMPORTANT
  
  
  while( currentIndex < charNB ) {
    switch ( line[ currentIndex++ ] ) {              // Select command, if any
      case 'G':
        switch ( atoi( line+currentIndex ) ){                   // Select G command
		  case 28: 
			home();
		  case 92: 
			break;
		  case 0:                                   // G00 & G01 - Movement or fast movement. Same here
		  case 1:
            char* indexX = strchr( line+currentIndex, 'X' );  // Get X/Y position in the string (if any)
            char* indexY = strchr( line+currentIndex, 'Y' );
            char* indexZ = strchr( line+currentIndex, 'Z' );
            if ( indexX != NULL ) { // Find new current position and direction of motion if available
              newPos.x = atoi( indexX + 1); // get value from the line char array as a int
            }          
            if ( indexY != NULL ) {
              newPos.y = atoi( indexY + 1); 
            }
			
            if ( indexZ != NULL ) { 
              newPos.z = atoi( indexZ + 1);
              if ( newPos.z < Zmax ){
				  penDown();
				  newPos.z = Zmin; Zpos = Zdmin;
			  }
              //if ( newPos.z >= Zdmax ){
				  else{
				  penUp(); newPos.z = Zmax; Zpos = Zdmax; 
				  }
            //  newPos.zDirection = ( (newPos.z - actuatorPos.z) > 0); // Determine direction of motion - incorrect for zero motion
            ////  if ( !actuatorPos.zDirection && newPos.zDirection ) newPos.z += BACKLASH; // if servo switches from a negative to a positive direction add backlash
             // if ( actuatorPos.zDirection && !newPos.zDirection ) newPos.z -= BACKLASH; // if servo switches from a positive to a negative direction add backlash          
            }
            //servoZ.write( newPos.z);   // Drop or lift z-axis 
            //			only run command if movement is required
			
            if ( actuatorPos.x!=newPos.x || actuatorPos.y!=newPos.y ){
				//if(newPos.z == Zdmax){
				if(Zpos <= Zdmin){
					drawDotLine(newPos.x, newPos.y );
					newPos.z = Zmin;
					//drawLine(newPos.x, newPos.y );
					}
					else{
				drawLine(newPos.x, newPos.y );
					}
					
			}
            //Serial.println("ok"); // acknowledge as required by reprap standards to work with replicatorG
			
			actuatorPos = newPos; //Want to move to inside the line command but would be outside of scope
            break;
        }
        break;
      case 'M':
        buffer[0] = line[ currentIndex++ ];        // /!\ Dirty - Only works with 3 digit commands
        buffer[1] = line[ currentIndex++ ];
        buffer[2] = line[ currentIndex++ ];
        buffer[3] = '\0';
        switch ( atoi( buffer ) ){
          case 84:                                // M84 - kill motors
		  servoX.detach( );
		  servoY.detach( );
		  servoZ.detach( );
		  delay(9999999999); //Effectively kill unit indefinitely at endof job
            break;
          //default:
           // Serial.print( "!! Command not recognized : M");
           // Serial.println( buffer );
        }
    }
  }
}



void drawDotLine(float x2, float y2) { //Inputs are in mm, All Calcs within drawLine are in Deg!!
  //Note difference between positions: Original '0', Current 'pos', Ultimate Target 't', Immediate target '1'
 
  float x0 = Xpos; //current position in deg. 
  float y0 = Ypos; //current position in deg
  
  //Convert & SHIFT/INVERT ORIGIN!! Y axis inverted in Gcode.
  float xt = mm2degPivot(x2);//+Xdmin; //convert target position to DEG & offset by the unusuable initial X angle
  float yt = 179-mm2degRack(y2); //convert target position to DEG.
  
    //  Bring instructions within limits
  if (xt >= Xdmax) { xt = Xdmax; }
  if (xt <= Xdmin) { xt = Xdmin; }
  if (yt >= Ydmax) { yt = Ydmax; }
  if (yt <= Ydmin) { yt = Ydmin; }
 
  //Record the direction of this move for X & Y to help us correct for lost motion if the servo changes direction.
  oldDirX = newDirX; //Preserve the prior direction command
  oldDirY = newDirY; //Preserve the prior direction command
  newDirX = round((xt-x0)/abs((xt-x0+.00001))); //note the .0001 is to prevent divide by zero err. These variables are INT so it will round off. Can only be -1,0,1
  newDirY = round((yt-y0)/abs((yt-y0+.00001)));
	if (newDirX != oldDirX && newDirX != 0){
		xt = xt + BacklashAngleX*newDirX; //BacklashAngle = magnitude, newDir = direction
	}
	if (newDirY != oldDirY && newDirY != 0){
		yt = yt + BacklashAngleY*newDirY; //BacklashAngle = magnitude, newDir = direction
	}
	
  float x1=x0; //x1,y1 is a moving intermediate position between the beginning and target position
  float y1=y0; 
  float distTotal = abs(lineDist(deg2mmPivot(x0), deg2mmRack(y0), deg2mmPivot(xt), deg2mmRack(yt)));//Total move distance
  float tol = .5; //allowable tolerance in deg for when to stop segmenting lines and just go to the end position 
  int stepCount = round(ceil(distTotal/DotResolution));

  
  /// ATTEMPTING TO INSERT A <= symbol into the STEP COUNT BELOW 
  
  
		for (int i=0; i<=stepCount; i++ ) //i = incremented stepcounter to find intermediate drawable points along the desired slope based on the DOT resolution
		{ 
			if (((xt-tol) <= Xpos && Xpos <= (xt+tol)) && ((yt-tol) <= Ypos  && Ypos <= (yt+tol)) ){ //check if target position reached within tolerance
				break;
			} 
			
			x1 = x0 + i*(xt-x0)/stepCount; 
			y1 = y0 + i*(yt-y0)/stepCount;
			
			servoZ.write(ZdTouch+5); delay(DotStepDelay); Zpos=ZdTouch;  //Move UP JUST off the mug surface
			servoX.write(x1); Xpos = x1; //record current position in deg
			servoY.write(y1); Ypos = y1; //record current position in deg
			delay(DotStepDelay);
			servoZ.write(Zdmin); delay(DotStepDelay); Zpos=Zdmin;   //Move DOWN to draw a dot
			   //Delay before next lines to ensure this line is completed
		}
	//Move to original target positions & update position record
	servoX.write(xt); 	Xpos = mm2degPivot(x2); //record current position in deg
	servoY.write(yt); 	Ypos = 179-mm2degRack(y2); //record current position in deg

	delay(DotStepDelay);    //Delay before next lines to ensure this line is completed. Opted for the shorter delay time because it should already be @ the target
    //delay(LineDelay);    //Delay before next lines to ensure this line is completed
	//
}




void drawLine(float x2, float y2) { //Inputs are in mm, All Calcs within drawLine are in Deg!!
  //Note difference between positions: Original '0', Current 'pos', Ultimate Target 't', Immediate target '1'
 
  float x0 = Xpos; //current position in deg. 
  float y0 = Ypos; //current position in deg
  
  //Convert & SHIFT/INVERT instructions. Y axis inverted in Gcode & X origin position Xmin is at some number >0 deg.)
  float xt = mm2degPivot(x2);//+Xdmin; //convert target position to DEG & offset by the unusuable initial X angle
  float yt = 179-mm2degRack(y2); //convert target position to DEG
  
    //  Bring instructions within limits
  if (xt >= Xdmax) { xt = Xdmax; }
  if (xt <= Xdmin) { xt = Xdmin; }
  if (yt >= Ydmax) { yt = Ydmax; }
  if (yt <= Ydmin) { yt = Ydmin; }
 
  //Record the direction of this move for X & Y to help us correct for lost motion if the servo changes direction.
  oldDirX = newDirX; //Preserve the prior direction command
  oldDirY = newDirY; //Preserve the prior direction command
  newDirX = round((xt-x0)/abs((xt-x0+.00001))); //note the .0001 is to prevent divide by zero err. These variables are INT so it will round off. Can only be -1,0,1
  newDirY = round((yt-y0)/abs((yt-y0+.00001)));
	if (newDirX != oldDirX && newDirX != 0){
		xt = xt + BacklashAngleX*newDirX; //BacklashAngle = magnitude, newDir = direction
	}
	if (newDirY != oldDirY && newDirY != 0){
		yt = yt + BacklashAngleY*newDirY; //BacklashAngle = magnitude, newDir = direction
	}
	
  float x1=x0; //x1,y1 is a moving intermediate position between the beginning and target position
  float y1=y0; 
  float distTotal = abs(lineDist(deg2mmPivot(x0), deg2mmRack(y0), deg2mmPivot(xt), deg2mmRack(yt)));//Total move distance
  int tol = 5; //allowable tolerance in deg for when to stop segmenting lines and just go to the end position 
  int stepCount = distTotal/Resolution;

	if (distTotal > 10){  
		for (int i=0; i<stepCount; i++ ) //i = incremented stepcounter to find intermediate drawable points along the desired slope based on the resolution
		{ 
			if (((xt-tol) <= Xpos && Xpos <= (xt+tol)) && ((yt-tol) <= Ypos  && Ypos <= (yt+tol)) ){ //check if target position reached within tolerance
				break;
			} else if (stepCount <= 1){ //skip stepping if the move is already super small. 
				break;}
			
			x1 = x0 + i*(xt-x0)/stepCount; 
			y1 = y0 + i*(yt-y0)/stepCount;
			
			servoX.write(x1); Xpos = x1; //record current position in deg
			servoY.write(y1); Ypos = y1; //record current position in deg
			delay(StepDelay);    //Delay before next lines to ensure this line is completed
		}
	}
	//Move to original target positions & update position record
	servoX.write(xt);	Xpos = mm2degPivot(x2); //record current position in deg
	servoY.write(yt); 	Ypos = 179-mm2degRack(y2); //record current position in deg// Setting origin @ bottom left

	//if (newDirX != oldDirX && newDirX != 0){
	//	Xpos = xt- BacklashAngleX*newDirX; //record current position in deg
	//}
	//if (newDirY != oldDirY && newDirY != 0){
	///	Ypos = yt- BacklashAngleY*newDirY; //record current position in deg
	//}
    delay(LineDelay);    //Delay before next lines to ensure this line is completed
}

//  Raises pen
void penUp() {   //servoZ.attach( SERVOPINZ );
  //servoZ.attach( SERVOPINZ ); //I had experimented with detaching this motor when not in use to conserve power...
  servoZ.write(Zdmax); delay(penDelay); Zpos=Zdmax; 

  //servoZ.detach( );
}

//  Lowers pen
void penDown() {
  //servoZ.attach( SERVOPINZ ); //I had experimented with detaching this motor when not in use to conserve power...
  servoZ.write(Zdmin); delay(penDelay); Zpos=Zdmin;  

 // servoZ.detach( );
}

  //  Sends printer to home position without drawing on anything
  void home(){
    Zpos = Zdmax;	
	penUp();
	Xpos = Xdmin; //record current position in deg
	Ypos = Ydmax; 
    drawLine(Xmin,Ymax);
	delay(2000);
  }
  
  //Determine direct distance between two points in mm
float lineDist(float x0, float y0, float x1, float y1) { 
  //float temp = pow(pow(x1-x0, 2) + pow(y1-y0, 2), 0.5);
  return ((int) pow(pow(x1-x0, 2) + pow(y1-y0, 2), 0.5));
  }
  
  //  Draw a rectangle using two points
void drawRect(float x0, float y0, float x1, float y1, boolean toggle)  //inputs are in mm
  {
//  home();
  penUp();
  drawLine(x0,y0);
  if (toggle) { penDown(); }
  drawLine(x1,y0); delay(1000);
 // if (toggle) { penUp(); delay(penDelay); penDown(); }  //These intermediate pen toggles might be useful if the paper is wrinkling...
  drawLine(x1,y1); delay(1000);
  //if (toggle) { penUp(); delay(penDelay); penDown(); }
  drawLine(x0,y1); delay(1000);
 // if (toggle) { penUp(); delay(penDelay); penDown(); }
  drawLine(x0,y0); delay(1000);
  //if (toggle) { penUp(); delay(penDelay); penDown(); }
  penUp();
  }
 
   //  Draw a rectangle using two points
void drawDotRect(float x0, float y0, float x1, float y1, boolean toggle)  //inputs are in mm
  {
//  home();
  penUp();
  drawLine(x0,y0);
  if (toggle) { penDown(); }
  drawDotLine(x1,y0); delay(1000);
 // if (toggle) { penUp(); delay(penDelay); penDown(); }  //These intermediate pen toggles might be useful if the paper is wrinkling...
  drawDotLine(x1,y1); delay(1000);
  //if (toggle) { penUp(); delay(penDelay); penDown(); }
  drawDotLine(x0,y1); delay(1000);
 // if (toggle) { penUp(); delay(penDelay); penDown(); }
  drawDotLine(x0,y0); delay(1000);
  //if (toggle) { penUp(); delay(penDelay); penDown(); }
  penUp();
  }
