/* 
Mug-O-Matic/Post-It-Plotter- Gcode Reading Program
A complicated Arduino Sketch to read gcode sent via serial by a computer running processing.

HW License: Attribution-ShareAlike CC BY-SA 4.0
Last Updated AUG 2018

Attribution Credits:
 TO UPDATE BASED ON THAT GUY WHO MOSTLY CREATED THIS<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  Modified for current use by Michael Graham, https://engineerdog.com/
  Based on work by Makerblock, http://shor.tw/110
  Based on work by Heindal, https://www.thingiverse.com/thing:667454
  Based on work by Oliv4945: https://github.com/Oliv4945/GcodeMiniCNChttps://github.com/Oliv4945/Gc
 
// The Circuit per PINOUT IMAGE http://meped.io/mepedv2
//  A0 =  (Wifi Connection if in use)
//  A1 =  (Wifi Connection if in use)
//  A2 = (Ultrasonic Echo if in use)
//  A3 = (Ultrasonic Trig if in use)
//  A4 = (SCA Connection if in use)
//  A5 = (I2C SCL Connection if in use)
//  A6 = 
//  A7 = 
//  D0 (RX) = (Bluetooth TX connection if in use)
//  D1 (TX) = (Bluetooth RX connection if in use)
//  D2(S1) =  X axis servo
//  D3~(S2)= Y axis servo
//  D4(S3) =  Z axis servo
//  D5~(S4) =  
//  D6~(S5)= 
//  D7(S6)=  
//  D8(S7) =  
//  D9~(S8) = 
//  D10~(S9) = Buzzer long leg
//  D11~ = 
//  D12 = (IR Remote Input if in use)
//  D13 = (Embedded LED on this pin)
//  Any 5V =  
//  Any GND = Buzzer short leg
*/

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*DECLARATIONS*
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <Servo.h>

#define PIN_SERVO_X 2
#define PIN_SERVO_Y 3
#define PIN_SERVO_Z 4
#define LINE_BUFFER_LENGTH 512
//#define MOVEMENT_MIN 0
//#define MOVEMENT_MAX 80 
//#define STEP_DELAY 25  //ms
#define BACKLASH 1.5
//#define POSITIVE true
//#define NEGATIVE false

//Naming Components & Global Variables
struct point {
  int x;
  boolean xDirection;
  int y;
  boolean yDirection;
  int z;
  boolean zDirection;
};
struct point actuatorPos;
Servo servoX;
Servo servoY;
Servo servoZ;

float deg2mmRack(float deg) {return deg/2.25;} //  Converts mm to degrees for the servos.  2.25 is hard set by 180deg/80mm motion
float mm2degRack(float mm) {return mm*2.25;} //  Converts mm to degrees for the servos. 2.25 is hard set by 180deg/80mm motion
float deg2mmPivot(float deg) {return deg/(2.25/1.8);} //  Converts mm to degrees for the servos.  2.25 is hard set by 180deg/80mm motion
float mm2degPivot(float mm) {return mm*(2.25/1.8);} //  Converts mm to degrees for the servos. 2.25 is hard set by 180deg/80mm motion


// Define drawing settings
int BacklashAngle = 2; //deg added to all moves if a direction change occurs to account for slop/backlash in the system (This was a measured angle)
int Resolution = 1.75; //mm of minimum drawing resolution to consolidate impossible moves less than this distance into one movement of this length.
int StepDelay = 40; //ms delay between steps to ensure steps are independent moves. 
int LineDelay = 150; //ms delay after line move to ensure move is completed
int penDelay = 500; //ms delay to ensure pen move is completed
int oldDirX =0; //-1,0,1. Place holder to record the direction of the last motion in this axis to use for backlash correction.
int newDirX =0; //-1,0,1. Place holder to record the direction of the last motion in this axis to use for backlash correction.
int oldDirY =0; //-1,0,1. Place holder to record the direction of the last motion in this axis to use for backlash correction.
int newDirY =0; //-1,0,1. Place holder to record the direction of the last motion in this axis to use for backlash correction.

///*
//Specific to Mug-O-Matic
//  Define Robot limits, in degrees
int Xdmin = 12;  //43 if choked up
int Xdmax = 148; //137 if choked up
int Ydmin = 8;  
int Ydmax = 173;  
int Zdmin = 10; // 10. Dont want too tight or loose enough to lose contact!
int Zdmax = 50; //  Lifted Pen Position
//*/

/* 
//Specific to Post-It-Plotter
//  Drawing Robot limits, in degrees
int Xdmin = 25;  
int Xdmax = 179; 
int Ydmin = 20;  
int Ydmax = 160;  
int Zdmin = 110; //70  // Drawing engagement position (Z-dir Reversed between post-it-Plotter & Mug-O-Matic)
int Zdmax = 180; // Lifted Pen Position
//*/

//  Calculated drawing robot limits, in mm
float Xmin = deg2mmPivot(Xdmin);
float Xmax = deg2mmPivot(Xdmax);
float Ymin = deg2mmRack(Ydmin);
float Ymax = deg2mmRack(Ydmax);
float Zmin = deg2mmRack(Zdmin);
float Zmax = deg2mmRack(Zdmax);
int Xpos = Xdmin;   //Home Position (deg)
int Ypos = Ydmin;  //Home Position (deg)
int Zpos = Zdmax; //Home Position (deg)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*SETUP*
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void setup() {
  Serial.begin( 9600 );
  servoX.attach( PIN_SERVO_X );
  servoY.attach( PIN_SERVO_Y );
  servoZ.attach( PIN_SERVO_Z );
  // Set default positions
     home();

  actuatorPos.x = Xdmin;
 // actuatorPos.xDirection = NEGATIVE;
  actuatorPos.y = Ydmin;
 // actuatorPos.yDirection = NEGATIVE;
  actuatorPos.z = Zdmax;
 // actuatorPos.zDirection = POSITIVE;
  
  Serial.println( "start" );
  Serial.println( "// MiniCNC" );
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* Main loop*
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void loop() {
  char line[ LINE_BUFFER_LENGTH ];
  char c; 
  int lineIndex;
  bool lineIsComment, lineIsSemiColon;
  bool commandFound; // has a command been found 
 
  lineIndex = 0;
  lineIsSemiColon = false;
  lineIsComment = false;
  commandFound = false;
 
 while (true) { 
    // Serial reception - Mostly from Grbl, added semicolon support
    while ( Serial.available()>0 ) {
      c = Serial.peek();
      if ( ( c == 'G' || c == 'M' ) && commandFound ) { // check if the next character starts a new command
        c = '\n'; // insert a end of line character and skip reading the serial buffer to end the command  
      }else {
        c = Serial.read();
      }
      switch (c) {
        case '\n': // End of line reached
        case '\r':                         
          if ( lineIndex > 0 && commandFound ) {                        // Line or command is complete. Then execute!
            line[ lineIndex ] = '\0';                   // Terminate string
            Serial.print( "// Received "); Serial.println( line );
            processIncomingLine( line, lineIndex );
            lineIndex = 0;
            commandFound = false; // reset the command found flag to false
            lineIsComment = false;
            lineIsSemiColon = false;
          } else { 
            // Empty or comment line. Skip block.
          }
          break;
        case ';':
          lineIsSemiColon = true;
          break;
        case '(':
          lineIsComment = true;
          break;
        case ')':
          lineIsComment = false;
          break;
        case ' ':  // Throw away whitepace and control characters
        case '/':
          break;
        case 'G': 
        case 'M':
          commandFound = true;
        default:
          if ( (!lineIsComment) && (!lineIsSemiColon) ) {   // Only save if not comments
            if ( c >= 'a' && c <= 'z' ) {        // Upcase lowercase
              line[ lineIndex++ ] = c-'a'+'A';
            } else {
              line[ lineIndex++ ] = c;
            }
          }
          break;
       }
    }
  }

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*Function Definitions*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
/**********************
* void processIncomingLine( char* line, int charNB ) - Main loop
* char* line : Line to process
* int charNB : Number of characters
***********************/
void processIncomingLine( char* line, int charNB ) {
  int currentIndex = 0;
  char buffer[ 64 ];                                 // Hope that 64 is enough for 1 parameter
  struct point newPos;
  
  newPos = actuatorPos; // Set new position to current servo position, individual values are reused if new ones not list in command 
  
  while( currentIndex < charNB ) {
    switch ( line[ currentIndex++ ] ) {              // Select command, if any
      case 'G':
        switch ( atoi( line+currentIndex ) ){                   // Select G command
          case 0:                                   // G00 & G01 - Movement or fast movement. Same here
		  case 28: 
			home();
		  case 1:
            char* indexX = strchr( line+currentIndex, 'X' );  // Get X/Y position in the string (if any)
            char* indexY = strchr( line+currentIndex, 'Y' );
            char* indexZ = strchr( line+currentIndex, 'Z' );
            if ( indexX != NULL ) { // Find new current position and direction of motion if available
              newPos.x = atoi( indexX + 1); // get value from the line char array as a int
            }          
            if ( indexY != NULL ) {
              newPos.y = atoi( indexY + 1); 
            }
			
            if ( indexZ != NULL ) { 
              newPos.z = atoi( indexZ + 1);
              if ( newPos.z < Zmin ) newPos.z = Zmin;
              if ( newPos.z > Zmax ) newPos.z = Zmax; 
            //  newPos.zDirection = ( (newPos.z - actuatorPos.z) > 0); // Determine direction of motion - incorrect for zero motion
            ////  if ( !actuatorPos.zDirection && newPos.zDirection ) newPos.z += BACKLASH; // if servo switches from a negative to a positive direction add backlash
             // if ( actuatorPos.zDirection && !newPos.zDirection ) newPos.z -= BACKLASH; // if servo switches from a positive to a negative direction add backlash          
            }
            servoZ.write( newPos.z);   // Drop or lift z-axis 
            // only run command if movement is required
			
            if ( actuatorPos.x!=newPos.x || actuatorPos.y!=newPos.y ) drawLine(newPos.x, newPos.y );
            actuatorPos = newPos; //Want to move to inside the line command but would be outside of scope
            //Serial.println("ok"); // acknowledge as required by reprap standards to work with replicatorG
			
            break;
        }
        break;
      case 'M':
        buffer[0] = line[ currentIndex++ ];        // /!\ Dirty - Only works with 3 digit commands
        buffer[1] = line[ currentIndex++ ];
        buffer[2] = line[ currentIndex++ ];
        buffer[3] = '\0';
        switch ( atoi( buffer ) ){
          case 84:                                // M84 - kill motors
		  servoX.detach( );
		  servoY.detach( );
		  servoZ.detach( );
		  delay(9999999999); //Effectively kill unit indefinitely at endof job
            break;
          //default:
           // Serial.print( "!! Command not recognized : M");
           // Serial.println( buffer );
        }
    }
  }
}



void drawLine(float x2, float y2) { //Inputs are in mm, All Calcs within drawLine are in Deg!!
  //Note difference between positions: Original '0', Current 'pos', Ultimate Target 't', Immediate target '1'
 
  float x0 = Xpos; //current position in deg. 
  float y0 = Ypos; //current position in deg
  
  //Convert & SHIFT/INVERT instructions. Y axis inverted in Gcode & X origin position Xmin is at some number >0 deg.)
  float xt = mm2degPivot(x2)+Xdmin; //convert target position to DEG
  float yt = 179-mm2degRack(y2); //convert target position to DEG
  
    //  Bring instructions within limits
  if (xt >= Xdmax) { xt = Xdmax; }
  if (xt <= Xdmin) { xt = Xdmin; }
  if (yt >= Ydmax) { yt = Ydmax; }
  if (yt <= Ydmin) { yt = Ydmin; }
 
  //Record the direction of this move for X & Y to help us correct for lost motion if the servo changes direction.
  oldDirX = newDirX; //Preserve the prior direction command
  oldDirY = newDirY; //Preserve the prior direction command
  newDirX = (xt-x0)/abs((xt-x0+.0001)); //note the .0001 is to prevent divide by zero err. These variables are INT so it will round off. Can only be -1,0,1
  newDirY = (yt-y0)/abs((yt-y0+.0001));
	if (newDirX != oldDirX){
		xt = xt + BacklashAngle*newDirX; //BacklashAngle = magnitude, newDir = direction
	}
	if (newDirY != oldDirY){
		yt = yt + BacklashAngle*newDirY; //BacklashAngle = magnitude, newDir = direction
	}
	
  float x1=x0; //x1,y1 is a moving intermediate position between the beginnning and target position
  float y1=y0; 
  float distTotal = abs(lineDist(deg2mmPivot(x0), deg2mmRack(y0), deg2mmPivot(xt), deg2mmRack(yt)));//Total move distance
  int tol = 5; //allowable tolerance in deg for when to stop segmenting lines and just go to the end position 
  int stepCount = distTotal/Resolution;

	if (distTotal > 3*Resolution){  
		for (int i=0; i<stepCount; i++ ) //i = incremented stepcounter to find intermediate drawable points along the desired slope based on the resolution
		{ 
			if (((xt-tol) <= Xpos && Xpos <= (xt+tol)) && ((yt-tol) <= Ypos  && Ypos <= (yt+tol)) ){ //check if target position reached within tolerance
				break;
			} else if (stepCount <= 1){ //skip stepping if the move is already super small. 
				break;}
			
			x1 = x0 + i*(xt-x0)/stepCount; 
			y1 = y0 + i*(yt-y0)/stepCount;
			
			servoX.write(x1);
			servoY.write(y1);
			Xpos = x1; //record current position in deg
			Ypos = y1; //record current position in deg
			delay(StepDelay);    //Delay before next lines to ensure this line is completed
		}
	}
	//Move to original target positions & update position record
	servoX.write(xt);
	servoY.write(yt); // Setting origin @ bottom left

	Xpos = xt; //record current position in deg
	Ypos = yt; //record current position in deg
    delay(LineDelay);    //Delay before next lines to ensure this line is completed
}

//  Raises pen
void penUp() {   //servoZ.attach( SERVOPINZ );
  //servoZ.attach( SERVOPINZ ); //I had experimented with detaching this motor when not in use to conserve power...
  servoZ.write(Zdmax); delay(penDelay); Zpos=Zdmax;  
  //servoZ.detach( );
}

//  Lowers pen
void penDown() {
  //servoZ.attach( SERVOPINZ ); //I had experimented with detaching this motor when not in use to conserve power...
  servoZ.write(Zdmin); delay(penDelay); Zpos=Zdmin;   
 // servoZ.detach( );
}

  //  Sends printer to home position without drawing on anything
  void home(){
    penUp();
    drawLine(Xdmin,Ydmin);
	delay(1000);
  }
  
  //Determine direct distance between two points in mm
float lineDist(float x0, float y0, float x1, float y1) { 
  //float temp = pow(pow(x1-x0, 2) + pow(y1-y0, 2), 0.5);
  return ((int) pow(pow(x1-x0, 2) + pow(y1-y0, 2), 0.5));
  }
